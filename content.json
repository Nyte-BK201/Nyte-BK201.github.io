{"pages":[{"title":"","text":"Hey thereI’m currently a fourth-year undergraduate at ShanghaiTech, computer science major. I got admitted to Kyoto University doing computer networks &amp; algorithms. I will probably study another two years in Japan. Contact and social link: Github BiliBili Mail: linzhy@shanghaitech.edu.cn Seldom uses social media like twitter/ facebook.","link":"/about/index.html"}],"posts":[{"title":"CS110 Summary","text":"Computer Architechture 一些homework和project总结。 当时不太会的东西， 但可能稍微久一点以后也不会了。 Homework2:boundy case 边界条件应该积极与其他人交流，不是闭门造车，效率会好点 尽快确认正确性，排除正确性问题（quicksort的实现出了很多次错误） 有可用的算法参考，就使用。 测试应该手写case后尽快在合适的平台上测试（ubuntu），不应该嫌麻烦在macos上等死 尽可能复用函数，例如 doubll_item *head = list_head(list) ，减少重复实现代码造成的误差，也避免改动花费大量时间 quick_sort 交换指针尽量只交换其中数据，不交换指针本身 12345678910111213141516//lo for lower index, hi for higher indexalgorithm partition(A, lo, hi) is pivot := A[hi] i := lo - 1 for j := lo to hi - 1 do if A[j] &lt; pivot then i := i + 1 swap A[i] with A[j] swap A[i + 1] with A[hi] return i + 1 algorithm quicksort(A, lo, hi) is if lo &lt; hi then p := partition(A, lo, hi) quicksort(A, lo, p - 1 ) quicksort(A, p + 1, hi) 补码反码 反码解决正负加减都用加法的问题 补码解决两个0（正负0）的问题 Project1.1Horrible mistake during coding and no error messages raised: int *num = malloc( sizeof(int) ); Caution: +1for\\0 char* str = malloc( strlen(other_str) + 1 ); strtok() usage Read token by token. 123456789101112FILE* input;char buf[BUF_SIZE];//read buf line by linewhile(fgets(buf,sizeof(buf),input)){ //get token separated by IGNORE_CHARS token=strtok(buf,IGNORE_CHARS); //read until the line ends while((token=strtok(NULL,IGNORE_CHARS))!=NULL){ }} Strtok_r() 使用了外置的save_ptr, 解决一些concurrence strtol() usage translate str into long 123456char *end;const char *str;res=strtol(str,&amp;end,0);//errno out of rangeif(errno == ERANGE)return -1; sprintf() translate number into str 12345int num;//malloc '+1' to contain '\\0' string endchar *args=malloc(sizeof(num)+1);sprintf(args,&quot;%d&quot;,num); Project3 optimization of k-means不要想自己解决这个问题，应该先去找paper看看有没有更好的算法。 Openmp 优化：手动array reduction 12345678910111213141516#pragma omp parallel{ int * q_private = new int[N]; q_private[] init 0; #pragma omp for for (int i=0;i&lt;N;++i){ q_private[i] += i; } #pragma omp critical for (int i=0;i&lt;N;++i){ //manually add private array into saving array q[i] += q_private[i]; }} Simd优化 1234//翻intel 指令集找指令_mm_store_pd((double*)(a+i),_mm_add_pd(_mm_load_pd((double*)(a+i),_mm_load_pd((double*)(b+i))));//强制类型转换//struct type can be used the same as array (a[i] ==&gt; a+i) Homework 7 C++ template and reference passingNamespace and template/reference passing: 123456789101112131415161718namespace __Detail{ template &lt;typename T&gt; class link_list{ link_list();//default constructor void push(link_list &amp;new_node);//push a node; }}//constructor can not have a return specification__Detail::link_list&lt;T&gt;::link_list(){ //do something here}//Const parameter passingvoid __Detail::link_list&lt;T&gt;::push(const link_list &amp;new_node){ head-&gt;next=new_node; //notice the &quot;const link_list &amp;new_node&quot; here is a mark to pass the original variable to the function( a reference), not to make it a pointer} 重载运算符 123456789101112131415161718192021222324252627282930//const type &amp;it 表示一种c++语法糖，不复制参数，也不能修改传入参数//type&amp; 返回类型：返回已经有的某个变量、值，不是新值，不复制值提高效率/ 可以实现 a = b = ctype&amp; operator=(const type &amp;it) { _M_node = it._M_node; return *this;}type* operator-&gt;() const { return &amp;_M_node-&gt;_M_data;}//type&amp; :返回一个type类型的reference(适用于已经有的某个变量、值) 不复制值，用于提高效率/ 实现(*a) 复合操作type&amp; operator*() const { return _M_node-&gt;_M_data;}//type&amp;, 表示 ++a: 先令a+=1,然后返回增加后的atype&amp; operator++() { _M_node = _M_node-&gt;_M_next; return *this;}//type : 表示a++: b = a++ 先令b=a，然后a+=1//括号中int是用于区别前置、后置的额外形参(其实是个0)，没有用处// 与 ++a 的区别主要在于返回值是否已经+1, type&amp; 为锦上添花，提高效率：因为返回了 *this，不需要新值，而 a++需要一个temp 所以返回typetype operator++(int) { iter_type tp = *this; _M_node = _M_node-&gt;_M_next; return tp;} c++11 auto自动类型推断 123456789//使用type declare__detail::__List_node_base&lt;T&gt; *nt = _M_head._M_next;//使用auto，the same effectauto nt = _M_head._M_next;//iterator声明__detail::__List_iterator&lt;int&gt; *it=new __detail::__List_iterator&lt;int&gt;();//equal toauto it = new __detail::__List_iterator&lt;int&gt;(); Project4 Shell implementation with cProj4 is a realization of shell program. 主要遇到的问题： c中的string copy must be implemented with strcmp() or it is not reliable since the = is manipulation of pointer The copy of pointer will raise problem when editing the string but keep slient sometimes. The bug is somehow hard to find if you don’t realize this might be a reason. fork() and shell machenism The main thread need to be exsiting until the shell is shutdown, execve() (or this series of syscall) will kill this thread after the function with no return. So we need fork() to make it a new thread run the command. But built-in command will be executed by main thread. 123456789101112131415if( isBuiltInCommand() ){ runCommand();}else{ int childPid=fork(); if( childPid==0 ){ //这里需要处理pipe(多重命令) execve(command);//This is the child thread to run this command }else{ if(isBackgroundJob){ waidpid(childPid,NULL,0); }else{ backgroundJobs[num++]=childPid;//store background job's pid to track } }} Pipe and multi-pipe (1) | (2) | (3) 先判断是头/尾，然后用pipe()，redirect stdin/stdout 到fd[1]/fd[2]，把stdio传到下一个阶段。Really need patience to design. Background jobs Multithread wake-up/ kill syntax, need some caution.","link":"/2019/01/11/CS110%20Summary/"},{"title":"CS131 Summary","text":"宋富老师的Compiler课，东西很多，忘得快。记点框架，免得全忘了。 教材：Compilers: Principles, Techniques, &amp; Tools 2nd Lexical Analysis正则表达式Atomic reg: for every a in $\\Sigma$ , Epsilon: $\\epsilon$ Compound reg: $r+s,rs,r^*$ Transition diagrams (a graph representation of reg) 自动机Deterministic, DFA( widely used in lexical analyzers ); Non-Deterministic NFA Two algorithm: Reg=&gt;NFA=&gt;DFA Reg=&gt;DFA (more complicated) Reg =&gt; NFAAllows $\\epsilon$ transitions, move to another state without consuming any symbol. Crafting every symbols one by one with $L(\\epsilon),L(a),L(s)\\cup L(t)$ NFA =&gt; DFACalculate $\\epsilon$ passing and construct all possible subsets and corresponding input symbol. Rename each subset and reassemble with input symble. Reg =&gt; DFAEvaluate firstpos, latpos, nullable. Draw trees and construct DFA. Abstractive and a little complicated, needs reviewing according to tutorial in youtube. Minimize DFAForgot. Error Handling Panic Mode Phrase Level Context free language and parsingEliminate ambiguity Grammar rewrite Enforce precedence and associativity Top-down parsingRecursive-descent paringBacktracking, general, not efficient Eliminate left recursion: Immediate recursions All left recursions Predictive parsingNo backtracking, efficient, LL(k) Left-factoring Construct LL(1) parsing tableFor each rule $A\\rightarrow \\alpha$ : terminal a in FIRST($\\alpha$)? Add $A\\rightarrow \\alpha$ to M[A,a] $\\epsilon$ in $FIRST(\\alpha)$? Add $A\\rightarrow \\alpha$ to M[A,b] for all terminals b in $FOLLOW(A)$ $\\epsilon$ in $FIRST(\\alpha)$? and $ in $FOLLOW(A)$? Add $A\\rightarrow \\alpha$ to M[A,$] All undefined entries are errors Not a LL(1) grammar and error recovery. Bottom-up parsingOperator precedence parsingNot much impression, maybe not important. Construct LR(0) parsing tableLong journey, need tutorial on youtube SLR(1) parsing table建表时，reduce操作只向$Follow(A)$中加. Cautions to ambiguous grammar (left/right associative) LR(1)对一个state，包含所有可能的下一个input. LALR(1) parsing table引入reduce-redure conflict. Intermediate represnetation Abstract syntax trees 保留代码和流程，不能遍历、修改。 Directed acyclic graphs AST合并同值节点 Control flow graphs 冗余、保守的源信息 Single static assignment 每个变量只定义、赋值一次，有利于优化 Stack machine code 容易生成，兼容性好；难优化，难重用 3-address code 适合多个level的IR；占空间，语义消失 Compilation strategies Hight-level Mid-level Low-level 以上是期中前的内容，下面是期中后的内容","link":"/2019/11/16/CS131%20Summary/"},{"title":"Config on Remote Development 用服务器写项目","text":"Start to develop on server so some config to easy the workload is pretty important. ssh先配ssh免密登录，第一次需要输入服务器密码 12ssh-keygen -t rsassh-copy-id -i ~/.ssh/key.pub root@xxx.xxx.xx.xx 再配config，~/.ssh/config中加入 12345Host server Hostname xxx.xxx.xx.xx User root Port xxxx IdentityFile ~/.ssh/key 使用： 1ssh server 挂载目录之前已经配好了ssh 1sshfs server:/path/to/folder /path/to/mount/point 其他通过中间主机建立SSH连接 1ssh -t reachable_host ssh unreachable_host 创建到目标主机的持久化连接 1ssh -MNf &lt;user&gt;@&lt;host&gt; 没有SSH-COPY-ID命令的主机将你的SSH公钥复制到服务器 1cat ~/.ssh/id_rsa.pub | ssh user@machine “mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys” 继续SCP大文件（需要两遍都有rsync） 123rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_filersync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file local -&gt; remotersync –partial –progress –rsh=ssh $user@$host:$remote_file $destination_file remote -&gt; local 保持SSH会话永久打开（切换wifi时不会断开） 1autossh -M50000 -t server.example.com 'screen -raAd mysession' 其他服务器常用命令备忘查看基础信息 1uname -a","link":"/2020/01/14/Config%20on%20Remote%20Developmen/"},{"title":"FenwickTree and Counting Inversions","text":"Not very clever to forget all these. FenwickTree 树状数组CHN reference from zhihu Common data structure in programming contest to answer range query questions. Simple implementation and less functionalities, $O(n)$extra space, query and edit in $O(logn)$. Idea: represent every index in binary and save sum of all “smaller” index values, where “smaller” is defined by position of last non-zero bit (001 &lt; 010 &lt; 100, 011&lt; 100). That is, tree[(100)]=a[(001)]+a[(010)]+a[(011)]+a[(100)] . And we have tree[(010)]=a[(001)]+a[(010)],tree[(011)]=a[(011)], so that we can represent “larger” index with “smaller” one: tree[(100)]=tree[(010)]+tree[(011)]+a[(100)] by finding the next “smaller” index (caculate by i &amp; (-i)). NOTE: to avoid endless loop, we leave tree[0] zero and start the structure from tree[1]. 123456789101112131415void update(int pos, int v){ for(int i=pos;i&lt;=n;i=(i&amp;(-i))) tree[i]+=v;}int sum(int pos){ int res=0; for(int i=pos;i&lt;=n;i=(i&amp;(-i))) res+=tree[i]; return res;}int query(int l, int r){ return sum(r)-sum(l-1);} Counting Inversions OnlineUpdate fenwick tree with update(a[i],1) when the current number is a[i]. This means we mark a[i] as already presented and we can later count matching inversions use query(a[i],n) (every number larger than a[i] forms an inversion, so we use fenwick tree to count sum). Exercise: AtCoder ABC 190 F 每次移动，变化的inverison数量都是规律的，只需要算一次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--) const int N = 3e5+10;int n;int fen[N];void update(int i, int v){ for(int j=i;j&lt;=n;j+=(j&amp;(-j))){ fen[j]+=v; }}int sum(int i){ int res=0; for(int j=i;j&gt;0;j-=(j&amp;(-j))){ res+=fen[j]; } return res;}int query(int l, int r){ return sum(r)-sum(l-1);}int main(){ ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n; int a[N]; rep(i,0,n){ cin&gt;&gt;a[i]; a[i]+=1; } ll res=0; rep(i,0,n){ res+=query(a[i],n); update(a[i],1); } cout&lt;&lt;res&lt;&lt;endl; rep(k,0,n-1){ res-=a[k]-1; res+=n-1-(a[k]-1); cout&lt;&lt;res&lt;&lt;endl; } return 0;}","link":"/2021/02/23/FenwickTree%20and%20Counting%20Inversions/"},{"title":"GCD and LCM","text":"Rewind my little memories of number thoery.. GCD和辗转相除法(Euclidean Algorithm)123int gcd(int a,int b){ return b?gcd(b,a%b):a;} Idea: old divisor $\\div$ old remainder, until we have new remainder=0. Proof: suppose $a=b+c$ where $a&gt;b$, and $x=gcd(a,b)$. $\\Rightarrow x$ is the divisor of both $a,b$. $\\Rightarrow \\frac ax = \\frac bx + \\frac cx$ $\\Rightarrow x=gcd(b,c)$. Otherwise, suppose we have a greater divisor $y=gcd(b,c), y&gt;x$, we will have $\\frac by+\\frac cy=\\frac{b+c}y=\\frac ay=an\\ integer$. This is a contradiction to the assumption that $x=gcd(a,b)$ Now we can continue to let $b=c+d,x=gcd(c,d)$ until $d=0$, and $x$ is the last non-zero number. We replace the repeated subtractions by divisions and know the algorithm is correct. LCM1lcm=a*b/gcd(a,b) Idea: $a*b=lcm(a,b)*gcd(a,b)$ Proof: Think of prime factorization, $gcd(a,b)=prime(a)\\cap prime(b)$, and $lcm(a,b)=prime(a)\\cup prime(b)$. So multiply these two will have every prime of $a,b$ with exact times. C++17都是老黄历了，C++17已经增加了std::gcd()和std::lcm()，不用自己写了。 Simple ExerciseCodeforces 858A The k-rounding number ends with k zeros and is divisble by n. So $10^k$ and n are divisor of this number. K-rounding = $lcm(n,10^k)$ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,a,n) for(int i=n-1;i&gt;=a;i--)const int INF = 1e9;const int N = 100; ll gcd(ll a,ll b){ return b?gcd(b,a%b):a;} int main(){ ll n,k; cin&gt;&gt;n&gt;&gt;k; ll z=1; while(k--)z*=10; ll ans=n*(z/gcd(n,z)); cout&lt;&lt;ans; return 0;}","link":"/2021/02/18/GCD-and-LCM/"},{"title":"KMP and Suffix Structure","text":"感觉自己像个宝崽，不会的可真多 Prefix Function (Next or Fail or whatever the same name)KMP里用到的z[i]（prefix function，z function和prefix function可以互相转换，名字借用一下）表示字符串0…i最长相同前后缀（看了很多grandmaster代码，所有人的习惯都不一样，天知道都是怎么想的=_+，我选择保持下标一致，z[i]表示最长长度)。 通过递推，用z[0]~z[i]算出$z[i+1]$，主要思想是第i+1个字母能不能和“之前已经匹配上的最长串的下一个字母”相匹配。如果不行，递归退回次长的串，再尝试匹配。这里有个很奇妙的性质，对于当前的串0~i，最长前后匹配串长度为$z[i]$，次长为$z[z[i] - 1]$…这个套娃背后的原理是： 我们已经知道当前串前后能匹配的最长长度，前后这一段是相同的，因此次长的匹配串应该是0~z[i]这串的前后匹配 而0~z[i]串最长的前后匹配，就是$z[z[i] - 1]$ （减掉的1是保持下标一致，这样很丑，但是选择去掉的写法，z[i]的含义就改变了，其他地方就会变丑，最好的办法应该是让string下标从1开始，那又是另外一个麻烦了=_=） 12345678910vector&lt;int&gt; calc_z(string s){ vector&lt;int&gt; z(s.size()); int j = 0; for(int i=1; i&lt;n; i++){ while(j&gt;0 &amp;&amp; s[i] != s[j]) j = z[j-1]; if(s[i] == s[j]) j++; z[i] = j; } return z;} ExerciseCF536B 题意是给定的串p在原串s中出现的位置，求可能的s数量。 想法是从头到尾填空，如果前后有冲突，那答案是0，没冲突答案就是$26^{uncovered}$，uncovered是原串中放空的部分，可以随便填26个字母。直接做会超时，利用z function算出串p的最长匹配z[p], 次长匹配z[z[p] - 1]… 这样就可以在O(1)的时间内判断交叉k个字母有没有冲突：如果k等于 ${z[p], z[z[p] - 1], …}$ 的其中一个，那么没有冲突，前k个字母和后k个字母相同。 这个判断可以用set进行，也可以用bool array标记 vis[z[p]] = true。 bool array会快一点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,n,a) for(int i=(n);i&gt;=(a);i--)const int MOD = 1e9+7;const int INF = 1e9;const int N = 1e6+5;int nxt[N];int y[N];int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; string p; cin&gt;&gt;p; int l=p.length(); if(m==0){ ll z=1; rep(i,0,n)z=(z*26)%MOD; cout&lt;&lt;z; return 0; } rep(i,0,m)cin&gt;&gt;y[i],y[i]--; int j=0; rep(i,1,l){ while(j&gt;0&amp;&amp;p[i]!=p[j])j=nxt[j-1]; if(p[i]==p[j])j++; nxt[i]=j; } set&lt;int&gt; s; while(j&gt;0){ s.insert(j); j=nxt[j-1]; } int co=0, idx=0; rep(i,0,n){ if(y[idx]==i){ if(idx&gt;0&amp;&amp;(y[idx-1]+l-1&gt;=i)&amp;&amp;!s.count(y[idx-1]+l-i)){ cout&lt;&lt;&quot;0&quot;; return 0; } idx++; }else{ if(idx==0&amp;&amp;y[idx]&gt;i)co++; else if(y[idx-1]+l-1&lt;i)co++; } } ll ans=1; rep(i,0,co){ ans=(ans*26)%MOD; } cout&lt;&lt;ans; return 0;} CF126B 题意是找一个最长的子串，使其是prefix，suffix，还要出现在中间。 想法是这个子串如果存在，那么他得是s的最长前后匹配串，或者是次长串，或者是次次长串… 这样才能满足既是prefix，又是suffix。然后要验证这个串是否在中间出现过，就验证这个串的长度m存在于集合${z[1],z[2],..z[n-2]}$之中。可以用set做，也可以用数组标记，测试了下，set会慢很多（set是$O(logn)$毕竟）。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define rep(i,a,n) for(int i=a;i&lt;n;i++)#define per(i,n,a) for(int i=n;i&gt;=a;i--)const int MOD = 1e9+7;const int INF = 1e9;const int N = 1e6+5;int p[N];int vis[N];int main(){ ios::sync_with_stdio(false); cin.tie(0); string s; cin&gt;&gt;s; int n=s.length(); if(n&lt;=2)cout&lt;&lt;&quot;Just a legend&quot;; else{ int j=0; rep(i,1,n){ while(j&gt;0&amp;&amp;s[i]!=s[j])j=p[j-1]; if(s[i]==s[j])j++; p[i]=j; if(i!=n-1)vis[j]=1; } int m=p[n-1]; while(m!=0){ if(vis[m]){ rep(i,0,m)cout&lt;&lt;s[i]; return 0; } m=p[m-1]; } cout&lt;&lt;&quot;Just a legend&quot;; } return 0;} CF1326D2 题意是从前缀+后缀中找一个最长的回文串，不重叠。 想法是前后能匹配的部分拿的越长越好，肯定是最优的（假设有另外一个最优的回文串左边拿的不是最长的，那么可以去掉后缀第一个字母，加上前缀后面一个字母，他还是最优的）。中间的部分就要从子串的前缀和后缀找一个最长的回文串。有manacher这种专门算法在，但是现在还不需要，因为只需要以前缀或者后缀为开头的回文串。可以计算$s=s+”@”+reverse(s)$的Z function，那么s.substr(0,z[s.length() - 1])就是最长回文串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,n,a) for(int i=(n);i&gt;=(a);i--)const int MOD = 1e9+7;const int INF = 1e9;const int N = 100;string calc(string rs){ string s=rs;reverse(s.begin(),s.end()); s=rs+&quot;!&quot;+s; int j=0; vector&lt;int&gt; z(s.length()); rep(i,1,s.length()){ while(j&gt;0&amp;&amp;s[i]!=s[j])j=z[j-1]; if(s[i]==s[j])j++; z[i]=j; } return s.substr(0,j);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int t;cin&gt;&gt;t; while(t--){ string s;cin&gt;&gt;s; int l=s.length(),k=0; rep(i,0,l){ if(s[i]!=s[l-1-i]||i&gt;=l-1-i)break; k=i+1; } string sp=s.substr(k,l-2*k); string a=calc(sp); reverse(sp.begin(),sp.end()); string b=calc(sp); cout&lt;&lt;s.substr(0,k)&lt;&lt;(a.length()&gt;b.length()?a:b)&lt;&lt;s.substr(l-k)&lt;&lt;endl; } return 0;} CF471D 题意：在一串数字中找匹配的子串 将输入差分以后，KMP找匹配次数。匹配的办法是把text和pattern组合，$s=pattern+“！”+text$，然后算t的z function。因为“！”不会在pattern和text出现，所以z的中的最大值只能是pattern的长度，z[i]==text.length()就说明这个pattern出现了一次（这个方法找到的匹配是有重合的）。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define rep(i,a,n) for(int i=(a);i&lt;(n);i++)#define per(i,n,a) for(int i=(n);i&gt;=(a);i--)const int MOD = 1e9+7;const int INF = 1e9;const int N = 2e5+5;int aa[N],bb[N];int z[2*N];int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,w; cin&gt;&gt;n&gt;&gt;w; vector&lt;int&gt; a,b,ab; int tp; rep(i,0,n)cin&gt;&gt;aa[i]; rep(i,0,w)cin&gt;&gt;bb[i]; rep(i,1,n)a.push_back(aa[i]-aa[i-1]); rep(i,1,w)b.push_back(bb[i]-bb[i-1]); ab.insert(ab.begin(),b.begin(),b.end()); ab.push_back(MOD); ab.insert(ab.end(),a.begin(),a.end()); int j=0; ll ans=0; rep(i,1,ab.size()){ while(j&gt;0&amp;&amp;ab[i]!=ab[j])j=z[j-1]; if(ab[i]==ab[j])j++; z[i]=j; if(z[i]==w-1)ans++; } if(w==1)ans++; cout&lt;&lt;ans; return 0;}","link":"/2021/02/25/KMP%20and%20Suffix%20Structure/"},{"title":"OpenWRT配置备忘录","text":"记录一下怎么在上海科技大学内网配置openwrt来使用一些插件，以后可能还会用到。 已经丢了一次配置，绝对不能再丢一次了。 NAT和校园网登录设置 DHCP/DNS 关闭重绑定保护，上科大的网关用了挟制来打开认证页面，不关闭打不开认证。 自动登录 SSH到路由上传login.sh 这里改写了开源的脚本，来自 https://github.com/ShanghaitechGeekPie/WifiLoginer 的wget版本（openwrt自带wget，所以不需要其他插件，这个最方便） 记得填入账号密码 12345678910111213141516171819#!/bin/shuserName=&quot;&quot;password=&quot;&quot;result=`wget -q --header=&quot;Content-Type: application/x-www-form-urlencoded&quot; --no-check-certificate \\ --header=&quot;Cookie:JSESSIONID=D56359E00B58C7877668AAB44B3BFE31&quot; \\ --post-data=&quot;userName=$userName&amp;password=$password&amp;hasValidateCode=false&amp;authLan=zh_CN&quot; \\ https://controller.shanghaitech.edu.cn:8445/PortalServer//Webauth/webAuthAction\\!login.action -O-`resultSucess=`echo &quot;$result&quot; | sed &quot;s/.*success\\W*\\(\\w*\\)\\W*token.*/\\1/g&quot;`if [ &quot;$resultSucess&quot;x = &quot;true&quot;x ]; then echo &quot;LOGIN SUCUESS&quot;else echo $resultSucess echo &quot;Log in failed , Please try again&quot; exit fi Chmod +x login.sh 系统-计划任务 添加 10 */12 * * * /home/login.sh 每十二个小时登录一次，避免下线。经测试可以稳定运行一个学期，但不保证IP地址不变。 注意指令的login.sh位置，我习惯放在/home下 无线设置 网络-无线 停用802.11bgn(2.4G)。学校里2.4G污染比较厉害，又慢，没什么用的必要，关掉省点电。 打开802.11nac(5G) 测试一下，2020年5月25日，大概能跑到100Mbps（慢的时候80Mbps） 梯子设置酸酸R PLUS 或者 PASSWALL都可以，都挺好用的，但是切换节点不方便，建议梯子稳定的用。 点上自动订阅，点上自动切换，输一下订阅地址就不用管了。自动切换建议3600秒。 挂载硬盘（局域网共享） 链接硬盘，注意USB口，特别是USB3.0可能会有一些精简的固件不支持，选好固件。 系统-挂载点 选好UUID，挂载点选自定义起一个喜欢的名字 /repo，文件系统类型一般是exfat，或者ntfs，选上匹配硬盘的就行。 使用hd-idle（选好有硬盘休眠的固件，也可以自己装）。空闲10分钟休眠适合机械硬盘。 网络储存-网络共享（samba）目录填上挂载点 /repo；允许用户填 guest；勾上允许匿名用户；创建权限0777，目录权限0777。这就不考虑什么安全性了，你的wifi被入侵已经很不安全了，开上游客和全部权限就行，非常方便多设备。 WIN10和macOS可以在网络里面找到你的router，点开就能看见repo。 IOS自带的文件浏览器也可以看网络位置，Android推荐用ES浏览器，在网络里能找到repo。 内网硬盘设置好了，外网硬盘需要先设置IP穿透，再设置FTP服务器。考虑到我们学校内网不让这么操作，就算了。有需要再折腾。 BT （轻量NAS，路由下载）这个部分要考虑一下路由器的性能，如果性能比较差，跑这个会影响网络使用。 相对来说，国内各种openwrt包里的aria2有很好的界面，所以推荐使用aria2，不用开transmission。 Aria2: 关闭 BT设置-启用DHT。 有些站要求关闭 自行调整单个种子最大连接数等等下载参数 文件和位置-下载目录改为 /repo （刚才挂载的硬盘） PRC默认是6800 使用方法：浏览器输入 192.168.1.1:6800 （你的网关:PRC）进入Aria2的页面，和迅雷一样用就行了。下好的文件去挂载的盘里看就行。 记得偶尔备份设置和固件，惨痛的教训","link":"/2020/05/24/OpenWRT%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"What IF：如果我没书念","text":"念书是一件很难的事情，出国也是一件很难的事情。两件事结合在一起，加上没有钱，全部靠自己，就是无尽的苦痛。 最近总在后悔大一刚入学时候没有当铁分奴，有些可以轻易到手的GPA没有用时间精力去混，到现在这个地步想出国成绩就太难看了。 谈到后悔，从识字开始，我就明白“现在好好读书，不然以后会后悔”的中国社会伟大共识，但是理解归理解，真正去实践是非常难的事情：读书很难，考高分也很难，突然我意识到我可能智力没有合适的高，那就更糟了。但是话讲回来，读书太有用，如果智力不够高，就得用毅力扳回一城——顺带祈祷一下更聪明的人的方法论没你高效。最后还是只能后悔当初眼光不够长远（没想到语文课也应该努力混，更没想到政治课我拿了个c），毅力不够强大（把能混的bonus都混了，顺带努力混个奖学金，搞不好实验室混篇paper）。 但是后悔也没有意义，毕竟人生总是在regret this and that中度过，除非某天一场意外把我带走，不然势必还有无数次后悔：问题不大，现在才20出头，想想办法给自己整一套弥补过去的方法论，给未来的后悔备着。 总之，也不是没有学校可以念，只是混个ms一定有学上的，但是看了看我的预算，又觉得不行。从一开始就只能冲着奖学金去，没有奖学金就念不起，但是background不够，不妄自菲薄估计也就是中游水平（搞不好也没有）。但是选学校也得选点好的才值得上嘛。 ETH,EPFL 世界顶尖+不收学费，念的起，申不上 KTH,CTH 瑞典名校，收学费 没有奖学金念不起 TUD,TUE 荷兰名校，收学费 同上 EIT,Erasmus 欧盟游学，收学费 同上 TUM,RWTH 德国好学校 读得起，不会德语，只能上英授 京大，东大，东工 日本好学校，公立都念的起，但不想去日本 选校目录也供去不起美帝的老弟们参考吧，当然神犇直奔phd就行，不用交钱还能赚钱。 选了学校，顺带还有一年的准备时间。后悔已经后悔过了，现在爬起来还能准备准备。但我就算拼命挣扎，还是大概率申不到奖学金，甚至可能申请都申不到。学校的保研和申请又只能二选一，太妙了，这就是成绩不好，背景不硬又没有钱的折磨。三样每一样都不沾边，又想折腾一下玩点新花样，那就太难了。 到了明年这个时候，我已经被迫在这两者之间做出了选择，但我现在还没想好。如果我选择申请，最后没有书念，那我只能去校招，去打工，但我想读书。当然也许是我不想读书，只是读书和工作里面想要那个轻松的，然后混吃等死。 当然也有第三条路，实在不想上班我就gap一年。。。还是算了吧。 Update in Feb 21, 2021一年之期已至，没想到，经过这一年乱七八糟的事情，我还是考上了京都大学，准备踏上前往日本的求学之路。 不管怎么说，总算有书读了","link":"/2019/12/04/What%20IF%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E6%B2%A1%E4%B9%A6%E5%BF%B5/"},{"title":"MacOS&#x2F;Linux解锁网易云音乐灰色歌曲","text":"三分钟在macOS/Linux上解锁网易云，AppleMusic不符合我的使用习惯。 虽然方法通用，但是讲道理Linux上的网易云客户端还不如网页，将就吧。 环境要求：git nodejs 自行安装 12345678cd $HOMEgit clone https://github.com/nondanee/UnblockNeteaseMusic.gittouch music.shchmod +x music.sh# 打开host 在最后加入十个空行，避免脚本影响上面的内容sudo vim /etc/hosts 打开music.sh，写入 12345678910111213141516171819202122#!/bin/bashpattern='[(].*[)]'path=$HOME/UnblockNeteaseMusic/app.jshostpath=&quot;/etc/hosts&quot;author=&quot;nyte.xyz&quot;sudo sed -i '' '$d' $hostpathsudo sed -i '' '$d' $hostpathsleep 3ip=`ping music.163.com -c 1 | grep -o $pattern`ip=${ip:1}ip=${ip%?}sudo sh -c 'echo &quot;127.0.0.1 music.163.com&quot; &gt;&gt; /etc/hosts'sudo sh -c 'echo &quot;127.0.0.1 interface.music.163.com&quot; &gt;&gt; /etc/hosts'sleep 3(sudo node $path -p 80 -f $ip) 注意:这个脚本会删去你的host文件最后两行，然后重新添加因此 /etc/hosts 最后十行务必是空行。(脚本写的比较丑 但是能用） 运行这个脚本以后，网页将不能访问网易云，不挂脚本也不能使用网易云 不需要解锁使用需要手动删除 /etc/hosts 这两行。 使用方法1./music.sh 稍作等待后，会弹出： 1HTTP Server running @ http://0.0.0.0:80 打开客户端即可。脚本需挂着不能关闭。 有时候域名解析的ip地址变动，会出现客户端连接不到网络，需要关闭脚本重新启动+重开网易云。 加到bash里会方便点 123456# 或者其他shellecho alias\\ music=\\&quot;$HOME/music.sh\\&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc# 使用music 方法比较老了，没怎么关注更新，因为一直能用。","link":"/2019/12/22/macOS%E8%A7%A3%E9%94%81%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%81%B0%E8%89%B2%E6%AD%8C%E6%9B%B2/"},{"title":"为什么我不在社交网络上post我的生活","text":"讲那么多，其实理由就一个：我的生活post出来会被可怜。当然是开玩笑的，连可怜我的人都没有。 社交网络上总是有各种生活post，从摄影、徒步，到美食、旅游，甚至去了某个conference，competition。我表面上讲：羡慕，羡慕，其实心里真的很羡慕。 贫瘠到可怜的生活，大家都过得一样，发了某个动态无非是：那家伙过的和我一样。我想着过不一样的丰富生活，但是实际上办不到，每次都要强忍着悲痛打开动态，康康有没有某个特别让人羡慕的post，鞭策一下自己。鞭是有的，策目前还没有体现出作用。 所以说，贫瘠的生活都是一样的，丰富的生活各有各的丰富。 没有物理上的丰富生活，转换一下思想，过点精神上丰富的生活，貌似是可行的。旅不起游还买不起书吗？看书貌似还是比较可行的，羡慕别人也没有办法，不如安慰自己一下：好歹读了两本书，都说读万卷书行万里路嘛，一样的一样的。 但是讲回practicalness，人的塑造是inner和outter issues同时存在的，无视客观环境的影响，只强调个人意志不现实也不符合客观规律。凌晨四点起床拍摄朝阳，朋友圈一片吹捧：牛皮、羡慕、技术好，对于推动摄影这个兴趣有极强的正向作用。但是反观读个书，能坚持几十本发个圈子看起来也只是作秀，或者是装逼。 现实情况是，大家都默认读书是应该做的事情，即便你读了很多，也没有一种界限区分读了、没读的人。讲到“读书的习惯给人的气质有加成”，但是这件事情太遥远，远到也许五年也没有分别。好一点的情况是你自信自己的肚子里墨很多，偶尔掉掉书袋还能符合水平；差的情况就是害怕自己读书的水准没有自知之明，忐忑地、谦虚地表达一下：没什么，我很少读书的，这个恰巧我懂点。能一直保持谦虚，还能一直读书，建议读书读成在世孔子。 没什么，发两post我读了书嘛，但是想想就觉得不会有人点赞，开上帝模式还感觉自己在装逼，太尬了。我又不能讲： Hey there, take a look into my brain, I’ve got hurdreds of books inside. I’ve got knowledge and humors. I am a guy worth contacting. 如果我真是这样的人，还好；要是我没那么objectively interesting，完了，fuck my life, 我当时为什么要装这么一下。 读书，读他娘的，找不到合适的环境必然不能有效的执行。选择某种流行的、备受推崇的新兴趣更practical点，但是又想想社会语境总是强调读书，好像是某种反讽：我们假装推崇一下，当然有真大牛就真推崇。 所以，为什么我不在社交网络上post生活？ 因为我真的啥也不会，学点东西搞不好可以拯救一下我的朋友圈。","link":"/2019/11/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%9C%A8%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%8Apost%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/"},{"title":"京都大学知能情报冬季入试备考&#x2F;应试经验分享","text":"本篇文章首发于知乎，博客备档。 笔者为上海科技大学大四在读（June 2021毕业），出愿京都大学3 Feb,2021的知能情报入试（Oct 2021入学）后，经过三周的备考合格，分享一下光速备考合格经验。 警告：笔者有较好的英语/算法基础，并且稍有运气成分，以下时间线可能不适用于大部分人，请酌情参考 Timeline: 2020年7-8月：备考托福单词，口语 2020年8月底：托福首考，102分 —— 大四上学期开学，正常上课，关注各个大学信息 —— 2021年12月底：提交欧洲申请材料，得知京大知能可以申请线上考试 2021年1月 1日-7日：期末考试，course project 7日-10日：填写京大知能出愿材料，DHL寄出 11日-2月2日：备考 2021年2月 3日-4日：线上笔试、面试 10日：得到录取结果 1.Preface我在19年末（大三上）萌生出国读书的想法，比较晚，但不算太晚。从那时开始当分奴，尽量把每一门课的分数考高，但遗憾智力有限，在大四上修完所有学分后GPA 3.56/4.00。美国/香港/新加坡/欧洲的master读不起（德国读得起，但APS和GRE太麻烦了），phd也不太可能申到，故从2020年6月开始考虑日本，搜集信息。 我申请了两个北欧的带奖硕士项目，但没有奖学金念不起。因此申请是彩票，重心还是放在修考上。 2.Language Proficiency日语：完全不会，打算在确定去日本读书后学习，有需要进步才显著。 英语：得益于上科大的英语教学比例大，英语能力进步很平滑。到大三下，背了一个多月单词，考前对着手机录音机念了两天口语，托福首考102分，没有费什么劲，也不需要任何课程。如果对自己英语能力不自信，我推荐先直接备考一次托福，摸个底再分配时间。 3.Application to KyotoU因为疫情，我很担心能不能出愿这次考试。京大在12月底发了公告，确定知能专攻可以线上考试，很开心，把期末考试考完，准备出愿材料。 京大的材料很简单，依次是 申请表、成绩单、个人陈述、护照复印件、转账证明、收件地址、托福成绩复印件。申请要填写志愿实验室，需要花一点时间确认想去的实验室是什么情况。只有个人陈述需要认真准备。 我的个人陈述稍微修改了欧洲的申请。和写作文不一样，个人陈述平铺直叙，逐点说明你的优势、申请理由、毕业计划即可。按议论文写法，论点+论据，切忌按时间线写作。本想上淘宝找文书中介润色，心疼钱就用grammarly+scribens自己修了一下。（大概错漏百出，但是我坚信日本人的英语也不怎么样，他们看不出来） 上海到京大寄送DHL只用了一天，非常快，疫情之中的清流。 4.Paper-based Selection疫情中知能增加了paper-based selection（也就是书类选考）。根据号码观察，4月生35人出愿，21人通过；10月生29人出愿，22人通过。筛人不算太狠，但考虑到三万日元的报名费，还是挺狠的。 通顺的个人陈述+高英语成绩应该是通过书类的关键，毕竟成绩单上的成绩你也不能改变。。 5.Review for Written Exam知能考核科目很少，线代、微积分、算法与数据结构，而且题目比较简单，这是我三周备考的底气。由于线代后面有用到，还记得一些；我的算法基础很好；微积分忘光了；我的实际执行情况是： 第一周：打dota，整理过去问，从头学一遍微积分 第二周：打dota，继续学微积分 第三周： 前三天：打dota，微积分快学完了 考前四天，很急，屎淋到头了。翻开线代教材一看，根本看不完，google上找了两份言简意赅，配有练习题的lecture notes过一遍。简单看一遍算法与数据结构的内容。 所以考试前我的状态：微积分的部分，二重积分、偏导（多元微分学部分）只是看了一下。线代只做了lecture notes上面的二三十道题，只会计算，证明题只看了证明思路。算法全吃老本。 虽然有运气成分（没复习的部分只有微积分的那道梯度题，考场上想起来了），但是说明知能考试确实可以这么操作，因为考核很基础。兄弟萌只要多做一些准备，肯定考得比我好。 首先浏览所有过去问，确认历年考核范围和样题。知道都考些什么，哪些会，哪些不会，心里有个数。我一看过去问，微积分全部不会，线代会一半，算法不用复习现场想也想得出来，就知道把重心放在哪了。 微积分：大一的同济数学分析课本，完全超纲，就看看一两道例题是怎么计算的，还有一点点印象和课本绑定了。MIT单变量微积分：MIT single variable calculas B站有带字幕的视频课，我看完一个单元就把所有problem set里的题目做一下，对一对答案。稍微记一下之前不记得的知识点，加深印象，后面还有大片线代复习。 线代：本想用MIT的线代，大二上课就用的那本教材，但翻开一看实在太多了，信息密度也很低，不适合再用来复习了。过一遍3Blue1Brown的视频，帮助回忆一下直观印象：3Blue1Brown Linear Algebra。 google上翻了两三面找一份合适的lecture notes：lecture notes。这个notes没有涵盖SVD，similar matrix，QR decomposition，涵盖了一些其他不考核的内容。但用来速成非常合适，逻辑很清晰，一步步讲明我们为什么需要这个定理，它的前置定理等等。内容不多不少，极少的练习题里还出现了京大的过去问：证明eigenvalues of symmetric matrix are real。题目没有答案，但是在google上都能找到（stackoverflow, mathexchange之类的问答网站上对这类基础问题的回答都很详细，已经讨论烂了）。 再看一看证明题，速成一下：sample proof。 没有覆盖的部分可以再翻翻其他notes，或者看教材。 算法与数据结构：省时间，只看MIT&amp;stanford的lecture notes/slides熟悉熟悉：MIT introduction to algorithms Stanford CS161。只看文字，两三个“半天”就看完了 6.Written Exam2月3日大部分同学已经回家过年了，因此宿舍是个很好的线上考试地点。我整理了下室友的桌子，熟悉的环境，考前半小时起床，下床就考试，爽！ 流程是：进zoom=》在breakout session里用摄像头展示你的考试环境，展示你的4张A4纸是空白的=》等待开考=》发放考卷pdf链接和密码=》进入Breakout session，共享电脑屏幕并保证考试期间除了题目没有其他内容出现=》在breakout session中答题至考试结束=》在摄像头前展示你的所有答题纸正反面=》退出breakout session，使用扫描仪/手机app 扫描答题纸正反面并整理为一个pdf=》上传至指定链接 流程不复杂，听考官指挥就行。监考官口语口音很重，怕有人听不懂还把每句话都发在公屏上（挺搞笑的）。考试结束后，他们会逐个检查答案是否可以辨别，有无缺少。 线代考的相当基础，eigenvalue&amp;eigenvector, determinant, orthogonality; 微积分考的偏导，巨基础的定积分，梯度；算法与数据结构考的二叉树，树上的independent set。 除了independent set那题要想一下，其他都很基础，而那道题我学过。（所以说有运气成分，不过是其他题目我也有信心做出来的，学过的太多了，所有NP，approximation之类的题我大概都能做） 笔试应该只错了二叉树的最后一个小问，推导到后面不会算了，糊弄了下把答案直接填上去。 7.Oral Exam笔试4月生21进5，10月生22进9。和往年差不多。 面试根据个人陈述准备了一份稿子，背一背念一念。 准备了两三个问题的答案，其他的就临场发挥吧。流程：zoom等待=》到你的时候会自动进入breakout session，然后会有一个教授让introduce yourself in 5 mins。我是全部examinee的最后一个，等了两个小时，幸好是线上的面试，我可以在电脑前读读写写，看一会儿dota2直播。 面试的时候，教授那边不开摄像头，只能听到声音，不知道对面什么情况。完事领头的那个教授问其他教授有没有问题。一志愿教授做computer vision的，问我两个问题： 1.上科大有个很厉害的lab（信院院长虞老板），为什么我不去他们lab读研？（他一问，面试的教授们全笑了，声音很大。我表示三年制太久了，我怕到时候发现方向不合适，日本两年制，所以我来考日本） 2.讲一下segmentation主要的困难（我提到想做的工作有segmentation in computer vision and network architecture）？（我说我毕设在做point cloud segmentation，主要困难是point cloud比较稀疏） 因为是最后一个，临走时套了下近乎，道了个谢。一共七分钟吧。我听力很好（托福听力满分），因此面试时基本听得懂。因为教授们用的麦克风不好，而且所有人应该是共用一个麦，有一起考试的其他同学表示有几个问题没听懂/基本听不懂。如果听力很差，非常不建议线上的考试，面试听不懂会直接白给。 8.Results and Conclusions2月10日放榜，北京时间中午两点准时点开，有我的号码，随后收到了京大的邮件通知。有书读了，又可以混两年了。本来已经做好打算落榜后继续备考+申请，等夏季入试再战。感谢京大给了我一个机会可以快乐的度过大学的最后一个学期，可以在大四下做想做的事情（指打dota）。 4月生5进4，10月生9进4。和往年差不多。 很有意思的是，录取通知上给我分配的是二志愿的network media，而非一志愿的vision lab。很奇怪，但是很感谢岡部教授面试没问我问题，还把我捞起来。我完全摸不着头脑，因为他们lab目前一个外国人都没有，翻了下alumni也几乎没有中国人，不懂出于什么原因把我捞起来了。可能是我笔试成绩好，英语成绩也还行？ 京大的赞歌就是笨比的赞歌！感谢京大知能只考三科，不然我死都复习不完啊。。 总算是在一年之后，给了当初写下“What IF:如果我没书念”那篇文章的我一个交代：只要你努力了，就没有那么多What IF。","link":"/2021/02/11/%E4%BA%AC%E9%83%BD%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%83%BD%E6%83%85%E6%8A%A5%E5%86%AC%E5%AD%A3%E5%85%A5%E8%AF%95%E5%A4%87%E8%80%83-%E5%BA%94%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"title":"孤独和聚会——临近毕业有感","text":"收到了教务处选课指导的邮件，猛然反应过来新学期的选课没有我了。今天是2021年5月25日，5月30日毕业答辩，在校的日子一眼望得到头了。很奇怪，四年的美好本科生涯就要结束，熟悉又理所当然的日子也要结束，心里沉沉浮浮、乱七八糟的思绪飘了起来，塞满了，但是又讲不出来。 我从小就不是一个喜欢聚会的人，一部分原因是奶奶对我的巨大影响：过度节俭，不舍得在娱乐场所消费（这些消费通常很高且不理智，是激情消费）；一部分原因是一旦我坐在聚会现场，纵使整体上体验不错，也会有偶然的麻烦时刻让我质疑自己为什么要参加，例如回家时刻的暴雨，或者聚会现场腹泻——这类痛苦又尴尬的时刻通常会压过所有欢欣，成为你记忆里的“丰碑”，时刻提醒着你。 逐渐长大，我已经成为了那个惯于不参加聚会的人：不是极其重要的时刻，通常都没有我。这种习惯像织网，织满了我的生活，整个大学生活，我通常都是一个人吃顿食堂，一个人宅在寝室。舍友的聚餐，他们都习惯了不喊我，而我也会习惯性地拒绝，一个人随便吃一顿。惯于离群是坏事：我几乎回忆不起来和别人社交，出去聚餐、去玩的场景；惯于离群是好事：我的脑海里寥寥的聚会都是重要时刻（小学班级的晚会，初中毕业聚餐，高中舍友的碰面），我会珍惜和舍友在一起打Dota，提醒自己更珍惜connections。 我不是那个天生的“自闭孤儿”，但不得不说我已经是了。我开始不习惯和别人社交，不喜欢和别人出去玩，只是程度不太深，但我对自己的情商低下、交流能力低下有了一些体会。聚会是短暂的一瞬间，那些重要事件也和聚会一样，身在其中的时间仿佛不存在，只剩少少的画面，就像叶子上露珠干掉的痕迹。 工业化和信息化给了现代社会拒绝社交的权力：我不需要通过社交交换信息，也可以仅靠网络获取所有生活物资。这是种好事：我们有了能够选择的权力；这是种坏事：社会行为深深刻在DNA中，离群带来的孤寂感受时刻抓挠着我，但我又厌烦无止境的通勤、消费。 但无论如何，聚会是一瞬间的，孤独是长久的。我应当找到自己一生的爱好，和自己相处。那些短暂的人生高光和重要时刻，终将消磨在无边无际和自己相处的漫长人生里。就像我所逝去的中学和大学时光，我日夜所梦的无非是“回到过去”，回到那熟悉的good ol’ days，而不是聚会的狂欢。那些失去时光的平淡之处都像少年的初恋一样，虽然我从未有过恋爱。 昨日不再，真是遗憾。我试着在算法、逻辑、推理这些广阔又高远的山上走一走，让脑子保持敏锐，只希望将来不会感慨智力不再。","link":"/2021/05/24/%E5%AD%A4%E7%8B%AC%E5%92%8C%E8%81%9A%E4%BC%9A%E2%80%94%E2%80%94%E4%B8%B4%E8%BF%91%E6%AF%95%E4%B8%9A%E6%9C%89%E6%84%9F/"},{"title":"当我在玩游戏的时候，我在玩什么","text":"“苦闷起人生对于“有限”的不满，幻想就是人生对于“无限”的寻求，游戏和文艺就是幻想的结果。” 但要深究，游戏也没有那么高山流水，反而有些躲避现实生活的意味。 当我在玩游戏的时候，我在玩什么？ 逃避现实用“消磨时光，放松自己”的说法比较正面，沉重点说，是在逃离现实的责任和琐碎。并不是非要上纲上线，只是想起课后还没写完甚至还没开始写的作业，一份未完成的文件，明早还要上课、上班，而这样的时间还要与你日久天长，总有些无奈。能在电子游戏的世界里脱离桎梏已经是一种万幸。 我们周围总存在一种想法认为，人可以在闲暇的时间里给自己充电，看一本书，学一种语言和新技能。但是在这几年的实践里，我逐渐发现人的精力是有限的，在一个白天的主职之后，精力已经消磨殆尽，很难再去提起力量去充电，只剩下疲惫的、只想不停对着屏幕发呆消磨时间的自己。 不论是微博、抖音、bilibili，任何不需要思考，不需要想法的事情都可以是消磨时间的媒介，只是漫无目的的刷新、查看，不停循环，抚慰着自己，饥饿地、贪婪地进食着无用信息。但关上屏幕的那一刻，我看到时间的流逝有了极大的恐慌和一种自责：时间宝贵，我可以做任何事，但不应该什么都不做。 于是我想到了游戏。 朱潜光先生在《谈美》里谈到：“现实界是有限制的，…，人不安与此。要消遣这种苦闷厌倦，人于是自驾空中楼阁。幻想就是人生对于“无限”的追求，游戏和文艺就是幻想的结果。它们的功用都在帮助人摆脱实世界的将所，调出到可能的世界中去避风息凉。人愈到闲散时愈觉得单调生活不可耐，愈想再呆板平凡的世界中讯处一点出乎常轨的偶然的波浪，来排忧解闷。” 摘取这么多溢美之词，无非是掩盖我“推销”游戏的一点心虚而已。但到游戏中去寻找一些不可能中的可能，在架空世界里消磨时间也许更接近读一本书，陶冶一点情操，而不是纯粹消磨时间。 充电和休憩的平衡虽然我接受了九年义务教育，也有幸读上大学，但我还是发现：读完一本书，特别是严肃小说，需要极大的力量，而我的这种力量慢慢消磨了。能读完一本书固然是好的，但是没有没有这种能力，就需要循序渐进地再找回来。好游戏可能是一种选择，也是所有往读书路上走的最愉快的路。 读书=学习，游戏=读书，那当然游戏=学习嘛。 对我而言，读书，读完一本严肃小说，深入的体会作者的构想，那个世界线的瑰丽和苦痛，站在超越时间和现实的高度，去享受一段人生之外的人生，说到底和玩一场游戏没有分别。总有调侃谈到人生是一场游戏，只是大部分人玩不好《人生online》。现实的曲折让我总是回避去揭开伤口的严肃小说，但是越长大，反而想看看最糟糕的现实有多丑陋，最痛苦的疼痛有多刻骨，破罐子破摔，反而有种快意：就像抠掉伤口上的疤。 但是抱着这样的想法去玩游戏，就需要对游戏多有挑拣，至少先和快餐游戏say no bye。即使选出来了好游戏，也难以说服自己：我为什么不直接去读一本书？那道理很简单，你读得下去到是去读啊？……我还是回来玩两游戏实在。 即便游戏不是最好的提升自己的途径，在毫无意义的消磨时间，以及认真学习这两个极端里，给自己一个中间定位是很重要的：就算学不下去，也不要浪费时间。至少玩两个好游戏，锻炼一秒钟脑子。 被消解的生活意义长篇大论再长，还是不得不承认游戏是麻醉和娱乐方式。玩游戏既不会带来产出，比起学习得到的又少又浅薄。但有一个疑问一直在我脑海盘旋：把游戏作为生活意义的一部分是浅薄的吗？如果是，那么什么样的娱乐方式是雅致的？什么样的生活方式是积极的？ 我用我缺少的哲学素养思考了数个月，我在我的小script中写下一段对话： 机器人：沉醉某种娱乐方式，只是不停消耗着时间而没有任何产出，有产出的人生才有意义，否则你在社会意义上不存在。人的生活意义应该是增加自己的影响力，即增加自己的产出数量和质量。 我：也就是说，个体需要产出来证明自己的生活意义，是因为社会需要你的产出，但是产出是有门槛的，你需要经验和学习来提升产出质量。如果你竞争不过机器人，那么你的存在毫无价值！ 机器人：对于社会来说，确实如此。个体不能阻挡历史的发展：人类社会需要你的产出，那么所有人类的生活意义就是努力增加自己的产出。这样的发展是任何文明的内生力量，产出是永恒不变的主题。因此不能产出的个体失去了社会意义，被社会所排挤，也就失去了生活意义。 我：确实如此。不能融入社会的个体，甚至无法生存，更别谈任何生活意义。那么残障人生的产出能力低下，下岗工人很难再有稳定产出，即使个体努力追求产出，也有可能最后被社会所抛弃。 机器人：没错，这就是所谓物竞天择，适者生存。这个问题的根本原因，是人的生物性——人和其他任何地球上的动物没有区别。 我的结论是：追求产出的生活方式是积极的，提升产出质量和数量的娱乐方式是雅致的，是被社会推崇的。人是社会性动物，人在组成社会的同时，个体的生活意义被社会消解了：从亘古到未来，社会前进的方向决定了你的生活意义。你可以选择你的生活方式，但你必须追求产出。追求产出并不是你必须的人生价值，这是社会对你下的魔咒。 因此，追求产出可以自豪，但是不追求产出也没有原罪——如果你在工作、研究中已经实现了产出，那么纯粹的消磨时光可以接受。仔细思考，这也是各大娱乐媒体，八卦新闻，短视频赖以生存的根基，毕竟把时间砸这上面比玩游戏还差劲。 总结当我在玩游戏的时候，我在玩什么？ 当我在玩游戏的时候，我追求的是学习和放松的中间点，我在消磨时间，但我希望尽量提升我的产出。游戏当然不是最好的消磨时间方式，但是任何不追求产出的娱乐方式都没有原罪，游戏反而是其中的佼佼者：安全，稳定，花费少，还能学到一点知识。 如果我轻松实现了产出，有了稳定的社会价值，那么我将玩游戏作为我活下去的意义，好像…完全可以接受。不过，那就是另外一个故事了。","link":"/2019/12/30/%E5%BD%93%E6%88%91%E5%9C%A8%E7%8E%A9%E6%B8%B8%E6%88%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E5%9C%A8%E7%8E%A9%E4%BB%80%E4%B9%88/"},{"title":"总结2020，展望2021","text":"闲下来就开始胡思乱想是人之常情，在这个微妙的大四下，研究生有去处了，学分也修光了，剩下半年磨磨蹭蹭和随便做点什么的时间。 2020年一整年都在为”读书“奔波。准备托福，套磁，在各个大学的招生页面徘徊，修了一遍又一遍的材料，思来想去给自己丑丑的简历再添一笔。 年初，还在startup company搬砖，年末听闻给我画饼，说要给我股份的老板和其他初创员工因为股份问题起了纠纷。果然早点跑路是对的，信了饼才是笨b。 年中，疫情原因晚晚开学，但是作为一个门都不出，能吃四年食堂+便利店的人，几乎对我没有任何影响。比起去商圈吃饭，用省下来的钱和时间打个游戏，上个网，我更喜欢。死宅的时间多的像大海里的水，平时浪费了，要用的时候，挤一挤还是挺多的嘛。 年末，套磁复套磁，拒信复拒信。躺在发件箱里的二十封邮件不停提醒我：你没书读了。那可真是极度焦虑的一段时间。从套磁东京大学IIP，到套磁东工大IGP，没有一封给我肯定。翻来翻去欧洲各个项目，各个大学，发现没有免学费一个都念不起，或者不值得。直到十二月底，看到京都大学的线上考试通知，心想：就算是个彩票，好歹春节除夕夜前就知道结果，要是中了，可以过个好年。 接下来的剧情就像梦一样，2021年一月初最后一个邮寄application，拖延到接近deadline，幸好DHL用了一天就寄到了。晚晚的开始复习，浪费时间在打游戏上，在焦虑和紧张中看到过了材料审查，迎来初试。本来复习的就很少，没想到考的全会，只错了一小问。面试时，由于是最后一个，镜头前反复练习。线上考试难得，我把全部过程都录了下来，大概是人生第一个vlog，也是唯一一个考试现场vlog。 发榜那天，正好是除夕前一天。在DDNet的服务器里闹腾，反复刷新京大的录取结果页面。下午三点，准时放榜，开头四个数字，一眼就看到了我自己：1629号。很兴奋，很高兴，然后马上开始思考有没有更好的。吃碗里的还要看锅里的：京大考试前，常常想象京大读书是什么生活，在各大网站上搜索分享；录取后，想着欧洲的申请要是给我发奖学金就好了，NII那个带奖的硕博连读项目后面还能考。 2021的春节，是我目前度过的最快乐的春节。 到了新学期开学，学分修完了，录取通知也有了，百无聊赖除了重新捡起算法竞赛，没什么特别想做的了。甚至现在的毕设课题和以后研究生方向不同，都想混一混了事了。要是人生一直这样一帆风顺…嗯，仔细想想我的人生压根没有重大挫折，世界真是美好：初中高中打了六年游戏，临近高考还在看小说，还是上了个不会后悔的大学；大学玩了四年游戏，临近入学考试还是在玩游戏，还是考上了京都大学。淦，运气太好会不会折寿？ 2021的目标： 吃好喝好睡好。回家时那轻轻的行李箱我带着都疲惫，我自己都不太能放心一个人在异国漂泊（尽管日本也就在隔壁） 再努努力，把算法竞赛捡起来 背一背单词，再学一点日语 也许到了9月，快要赴日的那段时间，情况又不一样了；也许因为疫情影响，压根不能赴日；也许欧洲的项目真的给我发奖学金，我去了欧洲。难熬的焦虑时间短短，有盼头的日子还长。","link":"/2021/02/24/%E6%80%BB%E7%BB%932020%EF%BC%8C%E5%B1%95%E6%9C%9B2021/"},{"title":"算法竞赛备忘录","text":"有些坑要记一下，应该不会忘，但是随便写写 ceil(a/b) with int如果a,b均为int/long long，那么直接使用ceil(a/b)不行，因为a/b作为中间过程是int，会被trunc。 但是使用ceil((double)a / (double)b)还是不行，因为浮点数精度不行，总有你意想不到的奇怪意外。 用(a+b-1)/b来代替ceil()。原理是$$a=x*b+y$$，那么$\\lceil\\frac{a}{b}\\rceil = \\lfloor\\frac{a+b-1}{b}\\rfloor$，而int除法的floor是正确的。 Overflowlong long tp = a*a + b*b如果a,b均为int，是有可能溢出的，要保证a,b也是long long（至少 a*b时，a是long long） Lambda使用传值时会发生拷贝，因此[=](){}十有八九会导致TLE，要用[&amp;](){} 使用lambda进行sort by index，并且不改变原本数组的排列123456vector&lt;int&gt; dp(n);//dp有一些random valuevector&lt;int&gt; idx(n);iota(idx.begin(),idx.end(),0);//equal to rep(i,0,idx.size())idx[i]=i;sort(idx.begin(),idx.end(),[&amp;](int a, int b){ return dp[a]&lt;dp[b];});//使idx的内容变成dp从小到大的index值，即dp[idx[0]] &lt;= dp[idx[1]] &lt;= dp[idx[2]] &lt;= ... 这样可以不修改原本的列，同等的写法需要： 1234vector&lt;pair&lt;int,int&gt;&gt; dp(n);//pair&lt;index, value&gt;sort(dp.begin(),dp.end(),[](pair&lt;int,int&gt; a, pair&lt;int,int&gt; b){ return a.second &lt; b.second;});//sort后会改变原本的数组","link":"/2021/03/04/%E6%95%B0%E5%AD%A6%E9%A2%98%E5%B0%8F%E5%9D%91/"}],"tags":[{"name":"university","slug":"university","link":"/tags/university/"},{"name":"compiler","slug":"compiler","link":"/tags/compiler/"},{"name":"memo","slug":"memo","link":"/tags/memo/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"string matching","slug":"string-matching","link":"/tags/string-matching/"},{"name":"openWRT","slug":"openWRT","link":"/tags/openWRT/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"网易云音乐","slug":"网易云音乐","link":"/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"},{"name":"thoughts","slug":"thoughts","link":"/tags/thoughts/"}],"categories":[]}